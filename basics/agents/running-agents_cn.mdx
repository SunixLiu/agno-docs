---
title: 运行智能体
sidebarTitle: 运行智能体
description: 学习如何运行你的智能体以及处理输出
---

通过调用 `Agent.run()` 或 `Agent.arun()` 来运行你的智能体。工作原理如下：

1.  智能体构建要发送给模型的上下文（系统消息、用户消息、聊天历史、用户记忆、会话状态以及其他相关输入）。
2.  智能体将此上下文发送给模型。
3.  模型处理输入，并返回一条消息或一个工具调用。
4.  如果模型发起了工具调用，智能体将执行该调用，并把结果返回给模型。
5.  模型处理更新后的上下文，重复此循环，直到生成一条最终消息且不再包含任何工具调用为止。
6.  智能体将此最终响应返回给调用者。

## 基础执行

`Agent.run()` 函数用于运行智能体并返回输出结果——返回形式可以是 `RunOutput` 对象，也可以是 `RunOutputEvent` 对象流（当 `stream=True` 时）。例如：

```python
from agno.agent import Agent, RunOutput
from agno.models.anthropic import Claude
from agno.tools.hackernews import HackerNewsTools
from agno.utils.pprint import pprint_run_response

agent = Agent(
    model=Claude(id="claude-sonnet-4-5"),
    tools=[HackerNewsTools()],
    instructions="Write a report on the topic. Output only the report.",
    markdown=True,
)

# Run agent and return the response as a variable
response: RunOutput = agent.run("Trending startups and products.")

# Print the response in markdown format
pprint_run_response(response, markdown=True)
```

<Tip>
You can also run the agent asynchronously using `Agent.arun()`. See
this [example](/basics/agents/usage/basic-async).
</Tip>


## 运行输入

`input` 参数是发送给智能体的输入内容。它可以是字符串、列表、字典、消息、pydantic 模型或消息列表。例如：

```python
from agno.agent import Agent, RunOutput
from agno.models.anthropic import Claude
from agno.tools.hackernews import HackerNewsTools
from agno.utils.pprint import pprint_run_response

agent = Agent(
    model=Claude(id="claude-sonnet-4-5"),
    tools=[HackerNewsTools()],
    instructions="Write a report on the topic. Output only the report.",
    markdown=True,
)

# Run agent with input="Trending startups and products."
response: RunOutput = agent.run(input="Trending startups and products.")
# Print the response in markdown format
pprint_run_response(response, markdown=True)
```

<Tip>
    请参阅 [输入与输出](/basics/input-output/overview) 文档以了解更多信息，以及如何在智能体中使用结构化输入和输出。
</Tip>

## 运行输出

在非流式（不启用流）的情况下，`Agent.run()` 函数会返回一个 `RunOutput` 对象。以下是一些核心属性：

- `run_id`: 运行的 ID。
- `agent_id`: 智能体的 ID。
- `agent_name`: 智能体的名称。
- `session_id`: 会话的 ID。
- `user_id`: 用户的 ID。
- `content`: 响应内容。
- `content_type`: 内容的类型。如果是结构化输出，这将是 pydantic 模型的类名。
- `reasoning_content`: 推理内容。
- `messages`: 发送给模型的消息列表。
- `metrics`: 运行的指标数据。更多详情请参阅 [指标](/basics/sessions/metrics/overview)。
- `model`: 用于此次运行的模型。

详情请参阅 [RunOutput](/reference/agents/run-response) 文档。

## 流式传输

要启用流式传输，请在调用 `run()` 时设置 `stream=True`。这将返回一个 `RunOutputEvent` 对象的迭代器，而不是单个响应。

```python
from typing import Iterator
from agno.agent import Agent, RunOutputEvent, RunEvent
from agno.models.anthropic import Claude
from agno.tools.hackernews import HackerNewsTools

agent = Agent(
    model=Claude(id="claude-sonnet-4-5"),
    tools=[HackerNewsTools()],
    instructions="Write a report on the topic. Output only the report.",
    markdown=True,
)

# Run agent and return the response as a stream
stream: Iterator[RunOutputEvent] = agent.run("Trending products", stream=True)
for chunk in stream:
    if chunk.event == RunEvent.run_content:
        print(chunk.content)
```

<Tip>
对于异步流式传输，请参阅此 [示例](/basics/agents/usage/streaming).
</Tip>

## 流式传输内部事件

默认情况下，当你流式传输响应时，仅会传输包含模型响应的事件（即 `RunContent` 事件）。

但在智能体运行期间，还会产生许多其他类型的事件，例如工具调用、推理过程、记忆更新等。

你可以通过在 `run()` 方法中设置 `stream_events=True` 来流式传输所有运行事件。这将输出与智能体内部处理过程相关的所有事件：

```python
response_stream: Iterator[RunOutputEvent] = agent.run(
    "Trending products",
    stream=True,
    stream_events=True
)
```

## 事件处理

您可以通过遍历响应流，在事件到达时对其进行处理：

```python
from agno.agent import Agent, RunEvent
from agno.models.anthropic import Claude
from agno.tools.hackernews import HackerNewsTools

agent = Agent(
    model=Claude(id="claude-sonnet-4-5"),
    tools=[HackerNewsTools()],
    instructions="Write a report on the topic. Output only the report.",
    markdown=True,
)

stream = agent.run("Trending products", stream=True, stream_events=True)

for chunk in stream:
    if chunk.event == RunEvent.run_content:
        print(f"Content: {chunk.content}")
    elif chunk.event == RunEvent.tool_call_started:
        print(f"Tool call started: {chunk.tool.tool_name}")
    elif chunk.event == RunEvent.reasoning_step:
        print(f"Reasoning step: {chunk.reasoning_content}")
```

<Check>
`RunEvents` 能够提供关于智能体内部处理过程的完整信息，从而帮助您构建卓越的智能体体验。
</Check>

## 事件类型

根据智能体的配置，`Agent.run()` 和 `Agent.arun()` 函数可能会产生以下事件：

### 核心事件

| 事件类型                  | 描述                                                                                                    |
| ------------------------ | -------------------------------------------------------------------------------------------------------------- |
| `RunStarted`             | 标识运行开始                                                                                   |
| `RunContent`             | 包含模型的响应文本，以独立的块（individual chunks）形式呈现。                                                        |
| `RunContentCompleted`    | 表示内容流传输已完成                                                                        |
| `RunIntermediateContent` | 包含模型的中间响应文本，以独立的块（individual chunks）形式呈现。此功能在设置 `output_model` 时使用。 |
| `RunCompleted`           | 表示运行成功完成                                                                       |
| `RunError`               | 表示运行中出现了一个错误                                                                     |
| `RunCancelled`           | 表示运行取消                                                                             |

### 控制流事件

| 事件类型        | 描述                                  |
| -------------- | -------------------------------------------- |
| `RunPaused`    | 指示运行暂停            |
| `RunContinued` | 一个暂停的运行已经继续的信号 |

### 工具事件

| 事件类型          | 描述                                                     |
| ------------------- | -------------------------------------------------------------- |
| `ToolCallStarted`   | 指示一个工具调用的开始Indicates the start of a tool call                             |
| `ToolCallCompleted` | 工具调用结束的信号，包括工具调用的结果 |

### 推理事件

| 事件类型          | 描述                                           |
| -------------------- | ---------------------------------------------------- |
| `ReasoningStarted`   | 表示智能体推理过程的开始 |
| `ReasoningStep`      | 包含推理过程中的一个单步骤      |
| `ReasoningCompleted` | 推理过程结束的信号          |

### 记忆事件

| 事件类型              | 描述                                     |
| ----------------------- | ----------------------------------------------- |
| `MemoryUpdateStarted`   | 指示智能体正在更新其记忆 |
| `MemoryUpdateCompleted` | 记忆更新完成的信号           |

### 会话简介事件

| 事件类型                 | 描述                                         |
| -------------------------- | --------------------------------------------------- |
| `SessionSummaryStarted`    | 指示会话简介生成的开始   |
| `SessionSummaryCompleted`  | 会话简介生成结束的信号    |

### 前置钩子事件

| 事件类型         | 描述                                    |
| ------------------ | ---------------------------------------------- |
| `PreHookStarted`   | 指示预运行钩子的开始          |
| `PreHookCompleted` | 指示预运行钩子执行完成 |

### 后置钩子事件

| 事件类型         | 描述                                    |
| ------------------ | ---------------------------------------------- |
| `PostHookStarted`   | 指示后运行钩子的开始          |
| `PostHookCompleted` | 指示后运行钩子执行完成 |

### 解析器模型事件

| 事件类型                      | 描述                                      |
| ------------------------------ | ------------------------------------------------ |
| `ParserModelResponseStarted`   | 指示解析器模型响应的开始 |
| `ParserModelResponseCompleted` | 指示解析器模型响应的完成  |

### 输出模型事件

|  事件类型                     | 描述                                      |
| ------------------------------ | ------------------------------------------------ |
| `OutputModelResponseStarted`   | 指示输出模型响应的开始 |
| `OutputModelResponseCompleted` | 指示输出模型响应的结束  |

### 自定义事件

如果您正在使用自己的自定义工具，可以与其他 Agno 事件一同生成（yield）自定义事件。
您可以通过继承 CustomEvent 类来创建您自己的自定义事件类：

```python
from dataclasses import dataclass
from agno.run.agent import CustomEvent
from typing import Optional

@dataclass
class CustomerProfileEvent(CustomEvent):
    """CustomEvent for customer profile."""

    customer_name: Optional[str] = None
    customer_email: Optional[str] = None
    customer_phone: Optional[str] = None
```

随后，您可以在工具中生成（yield）该自定义事件。该事件将在内部被作为 Agno 事件进行处理，且您能够以访问其他任何 Agno 事件的相同方式来访问它：

```python
from agno.tools import tool

@tool()
async def get_customer_profile():
    """Example custom tool that simply yields a custom event."""

    yield CustomerProfileEvent(
        customer_name="John Doe",
        customer_email="john.doe@example.com",
        customer_phone="1234567890",
    )
```

更多详细内容，查看[完整样例](/examples/basics/agent/events/custom_events) .

## 指定运行用户和会话

在运行智能体时，您可以通过传入 `user_id` 和 `session_id` 参数，来指定所要使用的用户和会话。这能确保当前的运行记录与正确的用户及会话相关联。例如：

```python
agent.run("Tell me a 5 second short story about a robot", user_id="john@example.com", session_id="session_123")
```

更多详细信息，请参阅 [智能体会话](/basics/sessions/overview).

## 传入图片/音频/视频/文件

您可以通过传入 `images`、`audio`、`video` 或 `files` 参数，向智能体传递图片、音频、视频或文件。例如：

```python
agent.run("Tell me a 5 second short story about this image", images=[Image(url="https://example.com/image.jpg")])
```

更多详细信息，请参阅[多模态智能体](/basics/multimodal/overview).

## 传递输出模式

您可以通过传入 `output_schema` 参数，为特定的运行指定输出模式。例如：

```python
from pydantic import BaseModel
from agno.agent import Agent
from agno.models.openai import OpenAIChat

class TVShow(BaseModel):
    title: str
    episodes: int

agent = Agent(model=OpenAIChat(id="gpt-4o-mini"))
agent.run("Create a TV show", output_schema=TVShow)
```

更多详细信息，请参阅 [输入与输出](/basics/input-output/overview) .

## 暂停和继续一次运行

当启动“人在回路”（human-in-the-loop）流程时，智能体的运行可以被暂停。随后，你可以通过调用 `Agent.continue_run()` 方法来继续执行该智能体。

更多详细信息，请参阅 [人在回路 (HITL)](/basics/hitl/overview) 文档。

### 取消运行

可以通过调用 `Agent.cancel_run()` 方法来取消一次运行。

更多详细信息，请参阅 [取消运行](/execution-control/run-cancellation/overview) 文档。

## 开发者资源

- 查看 [智能体参考文档](/reference/agents/agent)
- 查看 [RunOutput 模式](/reference/agents/run-response)
- 查看 [智能体 Cookbook](https://github.com/agno-agi/agno/tree/main/cookbook/03_agents/README.md)